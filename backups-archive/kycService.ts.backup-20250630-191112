import { UserRepository } from '../repositories/userRepository';
import { getSumsubClient } from '../integrations/sumsub/client';
import { AppError } from '../utils/errors';
import logger from '../utils/logger';
import tierService from './tierService';
import { supabase } from '../config/database';

export interface KYCInitiateResponse {
  accessToken: string;
  userId: string;
  applicantId?: string;
  status: 'new' | 'pending' | 'completed' | 'failed';
}

export interface KYCStatusResponse {
  status: 'pending' | 'approved' | 'rejected' | 'expired';
  reviewAnswer?: 'GREEN' | 'RED' | 'RETRY';
  moderationComment?: string;
  rejectLabels?: string[];
  updatedAt?: string;
}

export class KYCService {
  /**
   * Initiate KYC process for a user
   */
  static async initiateKYC(userId: string): Promise<KYCInitiateResponse> {
    try {
      // Get user details
      const user = await UserRepository.findById(userId);
      if (!user) {
        throw new AppError('USER_NOT_FOUND', 'User not found', 404);
      }

      // Check if user already has KYC in progress or completed
      if (user.kyc_status === 'approved') {
        throw new AppError('KYC_ALREADY_COMPLETED', 'KYC verification already completed', 400);
      }

      const sumsubClient = getSumsubClient();

      // Create or get applicant
      const applicant = await sumsubClient.createApplicant(
        userId,
        user.email,
        user.metadata?.first_name || undefined,
        user.metadata?.last_name || undefined
      );

      // Generate access token for WebSDK
      const accessToken = await sumsubClient.generateAccessToken(userId);

      // Update user's KYC status to pending if it was 'pending' (new)
      if (user.kyc_status === 'pending') {
        await UserRepository.updateKYCStatus(userId, 'pending', {
          kyc_applicant_id: applicant.id,
        });
      }

      logger.info('KYC initiated for user', {
        userId,
        applicantId: applicant.id,
        status: applicant.review?.reviewStatus,
      });

      return {
        accessToken: accessToken.token,
        userId: userId,
        applicantId: applicant.id,
        status: this.mapReviewStatusToKYCStatus(applicant.review?.reviewStatus),
      };
    } catch (error: any) {
      logger.error('Failed to initiate KYC', {
        userId,
        error: error.message,
      });
      throw new AppError('KYC_INITIATION_FAILED', 'Failed to initiate KYC verification', 500);
    }
  }

  /**
   * Get KYC status for a user
   */
  static async getKYCStatus(userId: string): Promise<KYCStatusResponse> {
    try {
      const user = await UserRepository.findById(userId);
      if (!user) {
        throw new AppError('USER_NOT_FOUND', 'User not found', 404);
      }

      // If no KYC initiated, return pending status
      if (!user.metadata?.['kyc_applicant_id']) {
        return {
          status: 'pending',
          updatedAt: user.updated_at.toString(),
        };
      }

      const sumsubClient = getSumsubClient();
      const applicant = await sumsubClient.getApplicantStatus(user.metadata['kyc_applicant_id']);

      const kycStatus = this.mapSumsubStatusToKYCStatus(
        applicant.review?.reviewStatus,
        applicant.review?.reviewResult?.reviewAnswer
      );

      const response: KYCStatusResponse = {
        status: kycStatus,
        updatedAt: applicant.createdAt,
      };
      
      if (applicant.review?.reviewResult?.reviewAnswer) {
        response.reviewAnswer = applicant.review.reviewResult.reviewAnswer;
      }
      if (applicant.review?.moderationComment) {
        response.moderationComment = applicant.review.moderationComment;
      }
      if (applicant.review?.rejectLabels) {
        response.rejectLabels = applicant.review.rejectLabels;
      }
      
      return response;
    } catch (error: any) {
      logger.error('Failed to get KYC status', {
        userId,
        error: error.message,
      });
      throw new AppError('KYC_STATUS_FAILED', 'Failed to get KYC status', 500);
    }
  }

  /**
   * Process KYC webhook from Sumsub
   */
  static async processWebhook(payload: any, signature: string): Promise<void> {
    try {
      const sumsubClient = getSumsubClient();

      // Verify webhook signature
      const payloadStr = JSON.stringify(payload);
      if (!sumsubClient.verifyWebhookSignature(payloadStr, signature)) {
        throw new AppError('INVALID_WEBHOOK_SIGNATURE', 'Invalid webhook signature', 401);
      }

      const webhookData = sumsubClient.parseWebhookPayload(payload);
      const userId = webhookData.externalUserId;

      logger.info('Processing KYC webhook', {
        userId,
        type: webhookData.type,
        reviewStatus: webhookData.reviewStatus,
        reviewAnswer: webhookData.reviewResult?.reviewAnswer,
      });

      // Map Sumsub status to our KYC status
      const kycStatus = this.mapSumsubStatusToKYCStatus(
        webhookData.reviewStatus,
        webhookData.reviewResult?.reviewAnswer
      );

      // Update user's KYC status
      const additionalData: any = {};
      if (webhookData.reviewResult?.reviewAnswer) {
        additionalData.kyc_review_answer = webhookData.reviewResult.reviewAnswer;
      }
      if (webhookData.reviewStatus) {
        additionalData.kyc_review_status = webhookData.reviewStatus;
      }
      if (kycStatus === 'approved') {
        additionalData.kyc_completed_at = new Date().toISOString();
      }
      
      await UserRepository.updateKYCStatus(userId, kycStatus, additionalData);

      // If KYC is approved, check for tier upgrade
      if (kycStatus === 'approved') {
        await this.handleKYCApproval(userId);
      }

      // Log the event in audit table
      await this.logKYCEvent(userId, webhookData);

    } catch (error: any) {
      logger.error('Failed to process KYC webhook', {
        error: error.message,
        payload,
      });
      throw error;
    }
  }

  /**
   * Reset KYC for retry
   */
  static async resetKYC(userId: string): Promise<void> {
    try {
      const user = await UserRepository.findById(userId);
      if (!user) {
        throw new AppError('USER_NOT_FOUND', 'User not found', 404);
      }

      if (!user.metadata?.['kyc_applicant_id']) {
        throw new AppError('NO_KYC_FOUND', 'No KYC verification found', 404);
      }

      if (user.kyc_status === 'approved') {
        throw new AppError('KYC_ALREADY_APPROVED', 'Cannot reset approved KYC', 400);
      }

      const sumsubClient = getSumsubClient();
      await sumsubClient.resetApplicant(user.metadata['kyc_applicant_id']);

      // Update user's KYC status back to pending
      await UserRepository.updateKYCStatus(userId, 'pending', {
        kyc_reset_at: new Date().toISOString(),
      });

      logger.info('KYC reset for user', { userId });
    } catch (error: any) {
      logger.error('Failed to reset KYC', {
        userId,
        error: error.message,
      });
      throw new AppError('KYC_RESET_FAILED', 'Failed to reset KYC verification', 500);
    }
  }

  /**
   * Handle KYC approval - upgrade tier if applicable
   */
  private static async handleKYCApproval(userId: string): Promise<void> {
    try {
      // Get user's current tier
      const userTier = await tierService.getUserTierInfo(userId);
      
      // If user is on Tier 0 (Unverified), upgrade to Tier 1 (Verified)
      if (userTier && userTier.tier_level === 0) {
        await tierService.checkAndUpdateUserTier(userId, 'KYC verification completed');
        
        logger.info('User upgraded to Tier 1 after KYC approval', {
          userId,
          fromTier: 0,
          toTier: 1,
        });
      }
    } catch (error: any) {
      logger.error('Failed to handle KYC approval tier upgrade', {
        userId,
        error: error.message,
      });
      // Don't throw - tier upgrade failure shouldn't fail KYC process
    }
  }

  /**
   * Map Sumsub review status to our KYC status
   */
  private static mapSumsubStatusToKYCStatus(
    reviewStatus?: string,
    reviewAnswer?: string
  ): 'pending' | 'approved' | 'rejected' | 'expired' {
    if (!reviewStatus) return 'pending';

    if (reviewStatus === 'completed') {
      if (reviewAnswer === 'GREEN') return 'approved';
      if (reviewAnswer === 'RED') return 'rejected';
      if (reviewAnswer === 'RETRY') return 'pending';
    }

    if (['init', 'pending', 'prechecked', 'queued'].includes(reviewStatus)) {
      return 'pending';
    }

    return 'pending';
  }

  /**
   * Map review status to simple status for response
   */
  private static mapReviewStatusToKYCStatus(
    reviewStatus?: string
  ): 'new' | 'pending' | 'completed' | 'failed' {
    if (!reviewStatus || reviewStatus === 'init') return 'new';
    if (['pending', 'prechecked', 'queued'].includes(reviewStatus)) return 'pending';
    if (reviewStatus === 'completed') return 'completed';
    return 'failed';
  }

  /**
   * Log KYC event for audit trail
   */
  private static async logKYCEvent(userId: string, webhookData: any): Promise<void> {
    try {
      await supabase.from('audit_logs').insert({
        user_id: userId,
        action: 'kyc_webhook_received',
        resource_type: 'kyc',
        metadata: {
          applicant_id: webhookData.applicantId,
          type: webhookData.type,
          review_status: webhookData.reviewStatus,
          review_answer: webhookData.reviewResult?.reviewAnswer,
        },
      });
    } catch (error: any) {
      logger.error('Failed to log KYC event', {
        userId,
        error: error.message,
      });
    }
  }
}

export default KYCService;